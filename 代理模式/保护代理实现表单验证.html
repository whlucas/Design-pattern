<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>表单验证</title>
        <style>
            span{
                color: red;
            }
        </style>
    </head>
    <body>
        <div>
            用户名: <input type="text" id = 'userDom' name = 'username'>
            <span id="showUser"></span>
            密码: <input type="password" id = 'psDom' name = 'code'>
            <span id="showPs"></span>
            <button id= 'submit'>提交</button>
        </div>

        <script>
            // 保护代理
            // 前端这一块尽量能给后端减减压,帮后端做一些校验

            // 我先写一个表单,这个肯定是很low,是我们一上来就写出来的东西
            // 然后再用我的保护代理对他做一个修正

            // 要求用户名长度不能超过四个字,超过了我就提示你超过了四个字
            // 密码的长度不能低于6个字且不能为空

            // 先假定数据是可以发送成功的
            let flag = true; // 标志允不允许发送网络请求
            submit.onclick = function () {
                showUser.innerText = '';
                showPs.innerText = '';
                if(userDom.value === ''){ // 获得我这个用户名标签里面的值,看看他是不是空值
                    flag = false; // 如果是空就不能提交
                    showUser.innerText = '用户名不能为空' // 出来一个提示
                }else if(userDom.value.length >= 4){ // 用户名长度大于4也不行
                    flag = false;
                    showUser.innerText = '用户名长度不能大于4'
                }

                if(psDom.value === ''){
                    flag = false;
                    showPs.innerText = '密码不能为空';
                }else if(psDom.value.length < 6){
                    flag = false;
                    showPs.innerText = '密码长度不能小于6'
                }
                if(flag){
                    // 发送网络请求
                    Requset();
                }

            };


            // 一个发送网络请求的函数
            function Request () {

            }


            // 我先在这样写特别的不好
            // 绑定的函数比较的庞大,包含了很多的if-else语句,这些语句需要覆盖所有的检验规则
            // 绑定的函数缺乏弹性,如果增加了一种新的校验规则,或者想要把密码的长度校验从6改成8,我们都必须深入修改,违反了开闭原则
            // 算法的复用性差,如果程序中增加了另一个表单,这个表单需要进行一些类似的校验,那我们很可能将这些校验逻辑复制的漫天遍野

            // 但是我写的需求如果只有这么简单,我不考虑后续的系统扩展,我不也不需要在其他地方去重复的利用这些需求,我就没必要把设计植入到里面去,只会增加时间成本


            // 策略模式
            // 策略模式是指对一系列的算法的定义,并将每一个算法封装起来,而且是他曼还可以相互替换,策略模式让算法独立于使用他的客户而独立变换
            // 策略模式的优点有:策略模式提供了管理相关的算法族的办法、策略模式提供了可以替换继承关系的办法、使用策略模式可以避免使用多重条件转移语。
            // 也就是这个算法可以进行灵活的变化，而且不用通过继承的关系来进行添加新的方法



            // 把代理模式 + 策略模式结合一下来重新一个好的

            // 策略模式支持您在运行时选择算法，把他们一个个封装起来，并且使他们可以相互替换。
            // 决定用一个类对象实例来管理规则的校验
            // 改对象要能相应的主动添加对规则的相应的处理办法
            // 校验数据的时候可以相应的返回相关的信息

            // 一个发送网络请求的函数
            function Request () {

            }
            Validator.prototype.strategies = {
                isNonEmpty: function (value, errorMsg) { // 我这个策略需要两个参数,一个是输入框的值,一个是错误信息
                    if (value == ''){
                        return errorMsg;
                    }
                    return true;
                },
                maxLeng: function () {},
                minLength: function () {},
            }


            // 构造函数, 用来实现策略模式的思想
            // 这个里面会有几个方法:

            // add 添加校验规则 参数(dom,showDom,[{strategy: 'isNonEmpty', errorMsg: '用户名不能为空'},{strategy: 'maxLength:4', errorMsg: '用户名长度不能超过4'},]) 第一个参数是控制哪一个dom,第二个是错误信息所显示的标签,第三个是很多个对象,每一个对象里面分别是策略和错误信息,每一个dom对象可以有很多个策略

            // start 上面添加完规则之后并没有开始校验,当我执行了start方法的时候就可以开始校验了,并返回真正的校验结果

            // extend 可以扩展算法{isMail: function() {}}
            function Validator() {

            }

            var validator = new Validator();

            // 写一个代理
            let ProxyRequest = (function() {
                // 当我点击的时候首先添加规则,添加一个用户名的规则,添加一个密码的规则
                validator.add(userDom, showUser, [{strategy: 'isNonEmpty', errorMsg: '用户名不能为空'},{strategy: 'maxLength:4', errorMsg: '用户名长度不能超过4'},]);
                validator.add(psDom, showPs, [{strategy: 'isNonEmpty', errorMsg: '密码不能为空'}, {strategy: 'minLength:6', errorMsg: '密码长度不能小于6'}])
                return function() {
                    if(validator.start() === true){ //执行校验,判断我这个start的执行结果是不是true
                        Request() // 如果是的话就发送请求
                    }

                }

            })();

            submit.onclick = function () {
                // 点击的时候直接执行我这个代理
                ProxyRequest()
            };
        </script>

    </body>
</html>