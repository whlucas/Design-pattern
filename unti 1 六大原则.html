<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <script>
            // 设计模式
            // 他有几种类型:
            // 1.创建型-研究如何高效的创建对象
            // 2.结构型-设计对象的结构和关系
            // 3.行为模式-设计对象的行为

            // 设计模式的六大原则:
            // 降低代码的复杂程度,合理的减少代码的耦合度

            // 耦合:两个事物之间如果存在一种相互作用、相互影响的关系，那么这种关系就叫做耦合关系
            // 只有函数、对象之间直接产生关系才能叫耦合,如果他们间接的有关系,比如一个函数改变了一个全局的变量,这个全局的变量会对另外一个函数产生影响,那么这两个函数之间就没有耦合
            // 没有耦合是不可能的,低耦合是合理的,过高不容易维护.但依旧拥有复用性和扩展性.因为耦合度高代表有很多个单独功能的对象和方法,表明没有把很多个功能杂合到一起写

            // 复杂度:可维护性,复用性,易扩展性,尽量功能和功能区分开

            // 优先降低复杂度,之后再尽量降低耦合度
            // 因为我在降低复杂度的时候,因为一般都是是靠增加耦合度来降低的

            // 1.利用单一职责的原则,开闭原则,里式代换原则降低复杂度,但是他们都是同过增加耦合度换来的

            // 2.通过迪米特法则来减少耦合度

            // 3.通过依赖导致原则消除可以没有的耦合




            // 使用设计模式的六大原则:

            // 第一个原则:
            // 单一职责原则(single responsibility principle)
            // 一个方法只做一个事情,请求数据的函数就不要渲染数据了
            // 写一个按照单一职责原则写一个请求并且渲染数据的模型(假代码!!!)

            // 根据数据渲染
            // function Render(dom) { // 创建对象的时候需要传入一个dom结构,让他天生就知道是哪个结构要被渲染
            //     this.dom = dom;
            //     this.do = function (data) {
            //         var htmlStr = '';
            //         arr.forEach(function(ele, index){
            //             htmlStr += '<li>' + ele.name + '</li>'
            //         });
            //         this.dom.innerHTML =htmlStr
            //     }
            // }
            // var oR = new Render(ul) //这里生成一个对象,说明要对哪一个dom操作
            //
            //
            // // 缓存数据
            // function CacheData(type) { // 数据名在创建对象的时候设置
            //     this.do = function (data) { // 数据值在调用函数的时候传入
            //         localStorage.setItem(type, data)
            //     }
            //     this.returnCacheData = function () {
            //         return localStorage.getItem(type)
            //     }
            // }
            // var oC = new CacheData('list')
            //
            // // 请求数据
            // function GetData(callBackArr) { // 由callback函数组成的数组
            //     this.getData = function (url, param){
            //         $.ajax({
            //             url: url,
            //             data: param,
            //             success: function(json) {
            //                 callBackArr.forEach(function(ele, index){
            //                     ele.do(json) // 成功了之后遍历数组,每一个对象都执行里面的do方法
            //                 })
            //             }
            //         })
            //     }
            //
            // }
            // var oG = new GetData([oR, oC]) // 这里传入两个callback分别是渲染和缓存
            //
            //
            //
            // // 就可以面对需求直接这样执行就好了
            // // 离线怎么样,有缓存怎么样,点按钮怎么样,就可以简单一点
            //
            // if(oC.returnCacheData()) { // 缓存里有数据
            //     if(!navigator.onLine){ // 离线
            //         oG.getData('xxx', 'page = 1') // 只能执行网络请求并且渲染且缓存了
            //     }else { //在线
            //         oR.do(oC.returnCatcheData()) // 用这个里面的数据来渲染
            //     }
            // }else{ // 缓存里没数据
            //     oG.getData('xxx', 'page = 1') // 只能执行网络请求并且渲染且缓存了
            // }
            // // 实现按钮的功能
            // oBtn.onclick = function(){
            //     oG.getData('xxx', 'page = 2') //请求一个新的页面
            // }



            // 第二个原则: 开闭原则
            // 核心是再写代码的时候,我要凭着我的经验来预测到那些地方需要发生改变,需要新增一些东西,在这些地方需要留一个增加方法的接口
            // 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭,函数里面的方法不能随便改
            // jquery面向扩展开放entend,面向修改关闭(他就是个大闭包,想改只能改源码),同时增强代码复用性
            // 在其他的语言中运用到开闭原则,如何来进行扩展:这个扩展的形式大部分是继承,父类有几个功能,但父类不足以满足我的需求了,我需要新增加一些功能,我不去改父类,我去拿一个子类继承他,在他的基础上新增一些东西
            // 这个我们不要在里面加,另去继承一个出来,或者扩展一个出来,也是降低复杂度的方式


            // 第三个原则: 里式代换原则 L Subsitiation Principle
            // 他为了保证我们用继承的方式去扩展的时候不出错
            // 任何基类可以出现的地方,子类一定可以出现
            // 通俗来讲就是: 子类可以扩展父类的功能,但不能改变父类原有的功能

            // 举个例子:
            // 一个宴会邀请父亲去,父亲去不了儿子也可以代替父亲去
            // 一个父类可以访问的接口,父类忙着其他事情,子类可以去访问

            // 他考研了我们对类的关系设计的能力
            // 用代码举个例子
            function Rectangle() { //矩形
                this.width = 0;
                this.height= 0;
                this.setWidth = function (width) { // 设置宽度
                    this.width = width;
                }
                this.setHeight = function (height) { // 设置高度
                    this.height = height;
                }
                this.getWidth = function () { // 设置宽度
                    return this.width;
                }
                this.getHeight = function () { // 设置宽度
                    return this.height;
                }
            }

            Square.prototype = new Rectangle() // 让这个方块类继承矩形类
            function Square() {
                this.setWidth = function(width) {  // 但是我这样继承的话就在自己的里面重新定义了一个setWidth和setHeight,调用的时候就会先调用这个,然后再在他的原型链上面去找父类的方法,这样就违背我里式代换的原则
                    this.width = width;
                    this.height = width;
                };
                this.setHeight = function(height){
                    this.setWidth(height);
                }
            }

            var oR = new Rectangle(); // new一个矩形对象
            oR.setWidth(200); // 用父级的set方法
            oR.setHeight(100);
            function Resize(o){ //我这个函数的功能是:如果我这个高度小于宽度,就把宽度+1去赋给他,让他比宽度大
                while(o.getHeight() <= o.getWidth()){
                    o.setHeight(o.getWidth() + 1)
                }
                console.log('over')
            }
            Resize(oR)

            var oS = new Square();
            oS.setWidth(200); // 假如我父类没了,我想用子类去调用父类里面的方法,由于我子类定义没有遵循里氏代换原则,所里这里就不能代替父级来完成工作
            oS.setHeight(200);
            // Resize(oS)



            // 第四大原则: 迪米特法则(最小知道原则) LD
            // 一个接口和一个方法.传入参数越少越好.降低耦合度的同事也会让复杂度降低
            // 一个函数的运行需要很多个函数运行的结果往里面传参的话,就会导致我这个函数的复杂度肯定不会低,因为要处理这么多参数,逻辑会复杂,他出错的概率也很大,相互影响性很强
            // 为了最大程度减少伤害,死只死一条线上的人,形成的关联越少越好
            // 尽量让他们的链接变成a只和b链接,b只和c链接,c只和d链接


            // 第五大原则: 依赖倒置原则 DIP
            // 最常用的原则,依赖接口,不依赖方法,底层的东西不用了解,我们只需要表现就可以.降低耦合度
            // js中没有接口的概念
            // 前端应用中可以理解成多者之间依赖:状态,而不依赖彼此
            // 比如我请求回来一个数据,请求成功的时候我不去调用很多函数,这样会产生很多耦合,当我请求成功的时候我去让一个状态量发生改变,我剩下的函数去监听我的那个状态,当状态变化的饿时候我去执行,这样来减少耦合


            // 第六大原则:接口分离原则 ISP
            // 把大接口拆分小接口,不能一个接口全部实现增删改查
            // 一个接口如果要实现很多功能的话他必定要接收很多参数,那么这个接口的复杂度就会提升
            // 一旦这个接口一旦不能用了,那么他里面的所有的功能就都不能用了,那么不稳定性就会提高
            // 比如我写作业,要细分成,写数学,写英语,写语文等作业

            // 在开发中我们需要提高耦合度来降低复杂度,但是提高耦合度会带来很高的风险,所以耦合度提高到多少来降低复杂度就需要一个权衡,需要一种风险的把控,风险的把控包括整个系统未来的可扩展性,可维护性,另一个方面是时间成本,不考虑这些规定可能会开发的很快,但是遵循他比如运用vuex来管控则会对未来的扩展来降低风险

            // 总结: 写代码先靠单一 开闭 里式给它分成很多块,最小知道让他们关系变得弱化,最后需要依赖倒置把没必要的偶合给它消除了,
            // 代码质量的高低是素质,学会权衡才是高价值的开发经验
        </script>
    </body>
</html>